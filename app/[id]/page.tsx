import { HOST } from "@/lib/const";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";

const sum = `
2023年9月7日 下午 5:00|32分钟 59秒 关键词: 客户端、前端、服务端、分享、自定义、浏览器、按钮、屏幕、背景色、颜色、源码、流程图、页面渲染、业务场景、用户交互、图片信息、页面链接、信息转化 文字记录: 常见的或者常用的解读方案有哪些？以及它们之间的一些区别。然后当初想做这个分享，主要是因为发现在其实很多业务场景里面都会支持用户通过截图的方式来进行对一些页面内容的分享，因为那个图片它会更清晰直观地展示这个分享者他想要传达的一些信息，而且相比于这个链接和文字，它的这个传播效率会更高。所以很多业务现在都增加了这个功能来帮助他们去提升自己的传播效率。然后在 MLBB 和 UGC 合作的这个方向下，我们也有一些类似的截图的需求，比如说海外周战报，然后他每周会给用户推送他这一周的战绩。同时我们在这个战报里面也提供了一个，就是一键将战报内容保存成图片的功能，然后我们会把这个图片再放到 TT 的那个发布器里面，帮助他一键发布成一个 TT 的图文视频，然后这样它同时就是这个功能，它同时可以帮助用户去渲染它的战绩，然后也可以就是提升 TT 里面 UGC 整体的这个内容的产出。 然后我们还有一个另外一个项目，就是ARGC，就是用户可以上传一张自己的图头像，然后我们会给它生成一个就是指定的 MRBB 英雄中的一个，就是偏就是跟他的头像相关的一个英雄的头像。然后我们在这个项目里面也有类似的截图的实践，就是我们会把用户生成前和生成后的这个图片放在同一个页面里面，然后我们支持把这个页面保存下来，方便用户后续的这个分享和传播。嗯，OK，就是前面就是大概给大家讲了一下我们现在业务中的一些截图的场景，然后下面就是简单地跟大家介绍一下，就是目前有哪些截图的方案可以使用。这也是我们前期在调研的过程中主要看的几个方案，分别是客户端、服务端和前端。然后我们先来讲一下客户端，它其实这个截图的方案就比较简单，也比较直观，因为就是像客户端，我们的手机和电脑它自带都会有一个截图的功能，因为就是我们页面，我们这个页面渲染出来这个图片，它其实本质上都是由一个一个的这个像素点组成的，然后每个像素点它都会代表一个颜色，那这个颜色我们可以通过这个 RGB 的这三个值来表示。
`;

const originText = `
2023年9月7日 下午 5:00|32分钟 59秒

关键词:
客户端、前端、服务端、分享、自定义、浏览器、按钮、屏幕、背景色、颜色、源码、流程图、页面渲染、业务场景、用户交互、图片信息、页面链接、信息转化

文字记录:
常见的或者常用的解读方案有哪些？以及它们之间的一些区别。然后当初想做这个分享，主要是因为发现在其实很多业务场景里面都会支持用户通过截图的方式来进行对一些页面内容的分享，因为那个图片它会更清晰直观地展示这个分享者他想要传达的一些信息，而且相比于这个链接和文字，它的这个传播效率会更高。所以很多业务现在都增加了这个功能来帮助他们去提升自己的传播效率。然后在 MLBB 和 UGC 合作的这个方向下，我们也有一些类似的截图的需求，比如说海外周战报，然后他每周会给用户推送他这一周的战绩。同时我们在这个战报里面也提供了一个，就是一键将战报内容保存成图片的功能，然后我们会把这个图片再放到 TT 的那个发布器里面，帮助他一键发布成一个 TT 的图文视频，然后这样它同时就是这个功能，它同时可以帮助用户去渲染它的战绩，然后也可以就是提升 TT 里面 UGC 整体的这个内容的产出。

然后我们还有一个另外一个项目，就是ARGC，就是用户可以上传一张自己的图头像，然后我们会给它生成一个就是指定的 MRBB 英雄中的一个，就是偏就是跟他的头像相关的一个英雄的头像。然后我们在这个项目里面也有类似的截图的实践，就是我们会把用户生成前和生成后的这个图片放在同一个页面里面，然后我们支持把这个页面保存下来，方便用户后续的这个分享和传播。嗯，OK，就是前面就是大概给大家讲了一下我们现在业务中的一些截图的场景，然后下面就是简单地跟大家介绍一下，就是目前有哪些截图的方案可以使用。这也是我们前期在调研的过程中主要看的几个方案，分别是客户端、服务端和前端。然后我们先来讲一下客户端，它其实这个截图的方案就比较简单，也比较直观，因为就是像客户端，我们的手机和电脑它自带都会有一个截图的功能，因为就是我们页面，我们这个页面渲染出来这个图片，它其实本质上都是由一个一个的这个像素点组成的，然后每个像素点它都会代表一个颜色，那这个颜色我们可以通过这个 RGB 的这三个值来表示。

所以如果我们可以将这个页面上渲染出来的这个页面上的每个点对应的颜色的信息拿到，那我们就可以将这个信息转化成为图片来保存。然后客户端因为它本身就是负责页面渲染的，所以它会将它显示的内容储存在一块 buffer 里面，那当我们触发这个截图操作的时候，它就可以将 buffer 中的这个信息提取出来，然后再将它转化成为图片的文件。

所以整体的这个客户端它截图的一个优点就是它速度是很快的，而且也没有什么其它的成本，但是它的缺点就是自定义的程度比较低，因为它只能截取当前这个用户看到的页面的部分。如果我们想要，嗯，截就是增加一些自定义的内容。就比如说我在截取这个页面的时候，我想去隐藏一个button，或者是增加一个文案，那这个时候我们就需要去把这个页面变化一下，这个时候用户就会感知到这个页面的变化，这个时候就要看就是产品他希不希望有这个内容的感知，如果不希望的话，那可能客户端的这个操作就不是特别的合适。然后如果前端想要使用客户端的这种截图的能力，可以通过就是宿调用宿主 APP 提供的JSB，就是在 TikTok 里面就有一个 JSB 是差点 capture by view，然后调用它，你就可以截取当前的这个页面了。OK，然后这个就是客户端的一个大概的思路。然后服务端截图的话，就是说我们可以搭建一个专门用来截图的服务，这个截图的服务就是我们前端比如说有一个按钮，这个按钮点击之后会帮用户去截图，那前端在用户点击了这个按钮之后，OK，玉米你的好像你的麦没有关。

记录你这个坑，哈哈。

OK，那我继续。然后前端就是他点击了这个按钮之后，他就会去调用这个截图服务的接口，截图服务他感知到这个前端过来的 request 之后，他就会在这个服务里面启动一个无头浏览器，它其实就是指一那个没有界面交互的浏览器，但是它又有就是。跟我们现在使用的这个浏览器有很多沟通的一些功能，我们可以通过代码来控制这个无头的浏览器来执行各种任务，比如说我们去指定让他去访问某个页面，然后去获取这个页面上的一些 DOM 信息等等。无头浏览器它就是大家常见的一些应用场景，就是爬虫。但是也有很多无浏无头浏览器，它是原生带一个就是截图的功能的，也就是说当我们就是在截图服务启动了之后，嗯，我们指定这个截图的这个服务中的梧桐浏览器去访问我们的这个页面的内容，这个页面的具体要访问哪个页面链接是可以通过前端在 request 里面去传参来决定的。然后无头浏览器在访问或者是渲染出来这个指定的页面之后，它可以调用就是它原生的这个 screenshot 截图的功能，然后去生成了一个这个页面的 base 64 格式的一个图片的信息，然后再回传给前端。

但是因为这个截图浏览器就是这个截图的，就是通过服务端截图的话，他因为首先我们需要重新在服务端那边把这个页面请资源请求到了，再重新去渲染一遍，所以它这个是有一定时间成本的，而且就是也需要考虑这个就是请求来回的这个时延，如果说用户他当地的网络不好的话，那他这个整体的接口时延是可能会很高的。

而且就是另外一个如果使用服务端截图的话，还需要考虑的因素就是它的服务端的成本，因为比如说像战报的业务，他每一周在就是下发战报的那个时刻，可能会有很多的用户会进来，那进来之后可能很多人都会去点击截图的按钮，那这个时候如果说流量很大的话，也需要考虑这个截图服务能不能撑得住。所以它就是有一定服务器的成本，也有一定的运维的成本。

但是截图服务端截图它的一个优点就是它的自定义化程度是很高的，因为我们就是截图的这个内容，它是由前端发的这个 request 里面参数决定的。也就是说如果我们传了一个跟当前页面不一样的，比如说URL，那它就可以截取对应的 URL 中内容，不一定是用户现在正在看到的这个，所以就是如果我们在截图的时候，这个产品指定的截图的内容跟当前页面渲染出来内容就是非常不一样的话，那我们就可以写两套，一套是专门为截图定制的内容，另外一套就是用来给用户交互的，那这样的话这个自定义的这个空间就会嗯大很多。

而且服务端截图的话，因为它是在服务端去进行的这个操作，所以就是在截图的时候，我们是不会去阻塞用户的任何的交互的，这也是他的这个优点之一。OK，然后到此就是差不多服务端的这个流程就介绍完了。嗯，然后最后一个途径就是通过前端截图，前端如果不借助客户端和服务端的话，那前端其实可以拿到的关于页面的信息基本上就只有 DOM 结构，所以前端的截图的大概思路就是我们先，嗯，拿到这个需要渲染的这一部分的到我们的结构，然后，嗯，你可以将它通过 canvas 的这个桥梁，然后你将这个 DOM 结构转化成为 canvas 的指令，然后再将这个页面在 canvas 中一点点画出来。

然后 canvas 这个元素，因为它本身自带一个就是方法，它是 to data URL，它支持当这个内容导出为 BYTE 464 的图片信息，然后拿到这个图片信息，你就可以去把它保存到本地了，这个是大概的一个思路。对，然后我们下面可以跟大家讲解一下，就是怎么将一个 DOM 的一个结构信息，然后，嗯，把它转化成为 class 指令，然后将这个页面的元素在 Kevin 上面复现出来。然后先简单讲一下canvas，就是 canvas 它本身就是一个画板，所以只要我们给的指令是正确的，那么我们其实就可以将这个 DOM 元素在 canvas 上面复现出来。然后这里有一篇就是讲解 canvas 的入门的一个文章，我觉得讲得还是挺好的，大家感兴趣可以点一下。

所以就是我们下面的核心，就是说我们怎么把 DOM 元素上的信息，比如说它的 CSS 的元素的信息，还有就是它的比如说 text 节点，还有 image 的内容，然后。把它转化成为对应的 canvas 的指令，然后假设我们现就是举一个例子的话，我们的页面里面有一张用户的名片，然后我们需要把它保存成为图片到本地这个用户的名片，其实它的结构也很简单，它只有一个背景色，然后里面有一张图片和一个用户的名称。那第一步的话，我们可能就需要先创建一个新的canvas，然后 t 就是 canva document 点 create element 就可以创建一个canvas，然后你可以把 canvas 想象成一张白纸，然后 canvas 点 get context 就可以去调取到，就是一些画图的工具。

对，然后第二步就是我们先去绘制这个背景色，背景色的话我们先可以通过，因为可以通过拿取它 CSS 中 background 的这个颜色，然后拿到这个颜色之后，我们可以把它赋值给 feel style，然后再借助这个 contact 上面这个填充色块的一个能力叫 feel react，然后在指定的区域里面把这个色块给填充上，那我们的背景色就可以绘制出来了。然后下面一步就是去绘制这个头像，绘制头像的话就可以新建一个 image 的元素，然后将头像链接复制给这个元素的source，然后再就是按照指定的位置，把这个图片也是可以就直接画出来。然后像这个文案的话，我们可以先拿到这个嗯，当前文案的它对应的字体的颜色，然后还有它的字的大小，还有它的对应的字体，然后调用这个 feel text 的方法也可以将这个文案在开发上面写出来。OK，然后到这的话我们就可以通过开发的指令将这个 down 元素在开发的上面画出来了。

画完之后我们可以通过就是调用这个 to data URL 的方法，拿到这个 BYTE store 的图片，然后你可以比如说把它塞到一个 i 链接帧 i 链接中，然后你再给它的这个设置好下载名称之后，你去点击这个链接，就可以将这个图片下载下来了。然后下面讲的是一个非常简单的例子，就是帮大家了解有一个概念，就是说怎么将一个页面的元素，嗯，在 camera 上面复刻出来，但是真实的情况肯定是比我上面举的这个例子要复杂的很多的，有很多的情况其实都需要考虑，比如说我们怎么样对各种 CSS 属性的支持，比如说我们怎么去绘制各种 border 的话，它就会分这里这个图片里面列举的这么多种。然后像background， background 的话你可能会有一些渐变色，渐变色要怎么支持？还有 font 的话可能就是关于字体，除了刚才说的字号，然后字体的类型，还有就是它的颜色之外，还有一些比如说它的 text decoration，就它的下划线等等，这些可能我们都需要，每一个每一种情况可能都是需要考虑到，然后把它转换成为对应的 canvas 的指令。

然后还有一些比如说 html 元素，像 input 元素里面它可能会有 Checkbox 和 radio 这两种的话，也需要我们一点点把它在那看板上面绘制出来。还有像一些列表的元素，因为列表元素它会在最开始的前面给它绘制一些符号，比如说圆圈或者是数字，那这些边际的情况其实都是需要考虑的。嗯，然后刚才其实上面讲的就是说我们怎么将一个元素在看板上面画出来。

除了将元素画出来之外，其实我们还需要考虑的就是说元素的前后的位置。因为可能默认的情况下，我们都知道就是后面的元素可以覆盖前面的元素，但是有一些 CS 属性，它是其实是会更改这个元素前后的位置的。这个元素前后位置其实就是说这个元素它是离屏幕更近还是离屏幕更远？比如说我们设置了一个 position absolute 元素， position absolute，那么这个 absolute 元素它就会默认覆盖其他的正常子元素。那对于都设置了 position absolute 元素， z index 值大的就会靠近屏幕， z 俊杰值小就会被覆盖。但是这个 z index 它又是指代同一个 stacking context，也就是这个层叠上下文中有效的。如果说有多个层叠上下文的话，就是说因为 CSS 中有很多属性，它都会触发一个新的层面上下文的生成，如果说有多种情况的话，其实这个也是需要考虑的。

上面其实说了这么多，其实想表达的就是如果我们去手动地将每一个 DOM 元素在看的时候没有看，完全没画出来的话，其实这个考虑的就是这个情况要有很多，而且这个成本是比较高的，所以还是就是建议通过现成的一些工具库来实现截图。然后目前比较常见的一个工具库就是 html to canvas，然后这个也是它实现的。这个原理就是跟我上面介绍的是差不多的，但是它会它的源码就看起来会更复杂一点，因为它就是对几乎每一种大部分就是 CSS 的属性都做了一个支持。

然后我下面就是贴了一个流程图，这个流程图就是它是这个代码里面它是怎么将一个 DOM 元素最终转化成为一个 canvas 的，它其实整个流程跟我上面介绍的差不多，简单讲一下的话就是它首先会将我们原始传进来的这个 doc 元素复制一份，克隆一份，空了一份之后他会去遍历整棵树，整棵 dump 树，然后会将 dump 树上相关的一些比如说它的 style 相关的信息汇总起来，然后会收集它的子元素的信息，然后以及就是这个元素它的它的边框的一些信息。然后它在收集完这些就是它绘制在开文上绘制所需要的属性。之后，它又会去重新再梳理一遍这棵树，然后它梳理这个树的目的就是为了捋清楚这些元素它们的前后位置，哪些元素是属于需要在最后一层的东，哪些元素是属于嗯，偏靠前的一层的？嗯，它在确定好这个元素的绘制顺序之后，它会先从最后面一层的元素开始绘制，然后这个时候绘制的时候就需要考虑到我们刚才说的怎么将一个元素，然后通过 canvas 指令画到 canvas 上，然后最后它就是可以得到一个绘制出图案的canvas，然后再把这个 canvas 返回给我们，再调用它的那个 to data URL 的方法就可以拿到就是这个页面的图片的信息了。

虽然这个库它现在已经比较成熟了，因为它大概是十几年前就已经有了这个库，但是它其实还是没有办法做到所有的 CSS 的属性的支持，然后在它的官网上有列出目前还没有被支持的属性，现在战报的线上的截图的方案其实还是用的是这个库，我们整体用下来感觉它的截图效果还是可以的，基本上 95% 的情况下页面内容都是可以被正确复现出来的。

那总结一下，前端这边的截图的话，就是它的整体耗时来说，相对于客户端来说肯定是更长的，但是会比服务端更可控一点，因为它没有网络的影响，同时它这个自定义化程度也比客户端的要高。这个高的意思就是说你可以去把一个想要截图的元素先隐藏，然后你在要截图的时候再把它传到这个库里面，然后它这个库就可以帮你生成出来这个图片，所以就不一定是要截，就是页面中可以展示出来的，然后那总结一下的话，就是客户端截图的优点就是它几乎是没有延时延迟的，但是它缺点就是自定义程度可能比较低。然后服务端截图的话，它的自定义程度比较高，而且不会影响用户交互，但是它的时间是比较高的，而且成本可能也会比较高。前端截图的话，它的优点就是自定义程度也比较高，但是也会有一定的时延，但是这个时延目前我们是比较就可以接受的，但是确实还是有一定的改进的空间。对，然后我其实今天的分享比较短，就是带大家粗略地过了一下，就是现在有的一些前端解读的方案，然后看大家有没有什么问题。

没有问题吗？没有问题我就结束。

诶，我问个问题啊，我看你例子里面写了一个download，是吗？

嗯，你是说你说这个生成图片这个 i 点 download 这个地方吗？

比如说你分享的时候怎么去把那个 download 再拿出来，再去做一个分享？

对。

这个就是这里。其实我是举了一个例子，然后像真实的就是业务场景里面的话，嗯，我在拿到这个 base 64 之后，然后我其实调的一个 TT 客户端的一个JSB，那个 JSB 它支持就是接收一个 BEST 64，然后它会帮我把这个图片存在客户端本地，然后我他就会返回给我一个图片地址，然后我拿这个地址再去，比如说再去做后续的分享。

OK，理解了，你这里只是演示，用一个 AA 的标签来做演示。

对对，就是让大家看到这个下载图片什么样子的，源码的话，就是因为我感觉它里面可能比较就是比较琐碎，所以我觉得可能分享的时候如果讲野马可能会比较枯燥，因为它源码里面有很多就是会考虑各种边界的情况，就是一些边界的情况，就 CSS 怎么转化到就是 canvas 的指令，我感觉可能就是在分享上面讲会，嗯，可能没有太大的必要。

嗯嗯，你开始不是说在看源码嘛，我看这里面好像没设置。

我就想说把这个大概它的流程就抽象出来，跟大家先介绍一下，对。

这块那个，嗯诶，这块那个宗展有啥要补充的吗？

其实是在这里个流程图，是吧？OK。

之前你们不是在搞长截图上海遇到一些问题吗？有什么要需要跟大家分享一下的吗？

有，其实之前安卓端在搞这个就是截图的时候，其实出会出现有一个问题，就是前端它会用这些 canvas 去绘制一些东西，然后实际上原先 TT 它提供了一个截图的一个能力，它并不能把前端这些 canvas 的东西给画出来了。画出来吗？其那时候其是因为 CAM 其前端用 canvas 去渲染出来的，是通过硬件去渲染的，但是 t 它提供的只有一种软件，软件渲染去获取它图像线索数的信息，所以实际上是需要去对 t 逻辑改造，然后增加就是 open GL 去绘制的。对，然后现刚刚纵横说的这个客户端方案，实际上之前也是通过加了一个占位图浮层的方案，是能够避免说用户去可以前端在截图的时候感知到那种前端一些页面元素的变化吗？就是它会在前端截图，前端是可以调用一个覆盖一层占位图的情况，然后那个截图的操作是在底下，就是占位图浮层底下去操作的，所以会达成一种既快速又客户端感知部不到变化的一种效果。

所以就是我记得那个战报，他现在不是也在慢慢地接那个客户端截图？因为当时这个需求我没有参与，所以对这个流程不是特别熟悉，但感觉好像就是说，比如说因为刚才宗展说的那个情况，就是比如说因为战报就这里列了三个图，因为战报它是有好几屏的，所以用户他可能在任何一个屏的下面去点击这个截图按钮，在这里没有展示出来，是因为那个我们不想把这个按钮也变点进去。

比如说如果用户他在第二页他去点击这个按钮的话，那就比如说我们调用客户端的能力，可能我理解就是他其实是需要先去滑动到第一屏的，那滑到了第一屏用户就会有感知，他可能会觉得我的屏幕为什么会突然被滚动？然后宗展说的意思就是我们可以就是在这个页面上保留一个蒙层，就是它最上面看到的还是第二页，但它其实下面那一页被滚动到了上面，然后客户端去先去截第一页，然后再截第二页，再截第三页。所以就是可能因为这个客户端截图时间很短，所以就是即使有这个蒙层，用户可能感知的也不是会特别。的明显，所以就也是可以接受的就是一个折中的方案。

可以的，宗展你那块的一些文档啥的也可以分享一下，到群里，有兴趣的同学可以去搞一下，去看一下。对，嗯。

嗯，好，可以。

诶，这一块是这个需求是实际上后面用客户端的截图来实现的，对吧？

对，就是因为最开始，因为客户端截图的优点就是它非常的快，然后前端截图的话，可能比如说像 iOS 也需要 2 到 3 秒或者甚至更长的时间，因为它是根据页面的数量决定的，但是客户端截图的话，它是基本上就是零点几秒，所以即使有很多页面的话，用户他等待的时间也是很短的。

那假如说你对比，比如说你本地测试一下，用前端这种方案来说会有很大的劣势，就是当初技术选型的时候有做比较充分的一个对比。

所以就是客户端截势截图的这个优势还是很大的，就防止用户在等待的这个过程中被流失了，真的。

了解 2 到 3 秒，确实有点长。

这块我们在设计的时候之前还考虑一种方案，就是嗯，相当于客户端，它首先是截当前屏幕的一个站外图虫，然后贴在当前的那个就是 window 上。然后这个时候有两种方案，第一种的话就是相当于客户端完全自己去截图，就客户端他把这个前端的这个 Web view，然后他从 0 的位置，然后滚动到，然后逐步从0，然后一页一页去滚动。然后第二种方案的话就是相当于前端它去控制这个滚动的那个范围，就比如说他滚前端，他从第一页然后截屏，去掉截屏，然后再收到那个嗯客户端的那个请求返回之后，然后再去滑动到第二屏，然后再去滚动。然后最后我们决定是用第二种方案，因为这样的话可能觉得就前端它可以自己去处理屏幕的大小，包括截图的位置就可能更具有一些是，就是普遍性。

其实我还是有点疑问，比如说你滚动加个蒙层，因为我不知道你截图的时候是能够把这个蒙层跟滚动区分开来吗？还是会客户端 each product？

客户端的话是相当于把这个 view 加在最上层的一个敞口上，这样的话它是不会去影响这个 Web view 视频的一个滚动区域的，就覆盖在最上，相当于一个 window 的上层，然后上面也会加一个 loading 的一个内容效果。

平时。

其实你可以理解为其实它那个蒙层和 Webview 是分开的， view 和前端页面分开的，那个蒙层是最上层的一个东西，然后那个 Webview 是会被那个蒙层给挡住的，然后那个蒙层我们也会把他的点击事件全部给取消掉，就是用户也不能对他上边进行一些操作的情况，对，不需要的。

诶，我理解，是不是你重新加载了一个隐藏的vivo，然后重新渲染了一遍？

因为其实它是单个Webview，我们这个蒙层是安卓的一个，就是类似于是一个 image view，然后把那 image view 给覆盖到 Webview 上边，都叠加起来，然后把那个 Webview 实际上是被挡在了那 image view 的下边。对，其就相当于它是两个组件，一个是显示图片的组件，那显示图片的组件把那个这个显示 Web 的一个组件给挡住了。

也可能，嗯。

它是两个窗口，对。

我有个问题就是如果我们都是基于就是客户端去做截屏，或者说基于前端去做截屏的话，会不会有一种情况就是截出来的效果不同的设备下面可能会不一样，比如说它是宽的那种设备，截出来的留白可能会更多一些，这种是怎么处理的？做统一bug。

会的，但是客户端 JSB 是有提供你截屏的一个区域的，就是你可以根据你的参数去截大概多长多框之类的一个限速，对。

那是不是都会跟着具体的业务能够动态去配置这些参数？哦，了解。还有就是就我们就业务侧截出来这个品，可能还要再去补充一些像二维码之类额外在页面之外的一些信息，这个是怎么去实现的？是截完屏客户端返回一个URL，然后前端在用 canvas 需绘制一张图出来吗？

不，不是，这个二维码实际上是被占位图浮层给遮挡之后，前端可以自己生成的，就生成之后直接在前端页面展示，然后他截的时候会一并截上去的。

OK，大家还有别的问题吗？

我想问一下，就是前端用 canvas 的 html to canvas 这一个库，它有很多的不支持的属性，那么客户端的不支持的属性有哪些？就是他们的能力覆盖范围什么样的？

是说客户端截图的时候吗？不支持的。

对，就是客，客就是客户端截图方案相比这个 html to cameras 这一个，它的一个兼容适配的这个 CSS 属性的广度对比是怎么样的？

其实这个可能需要宗展或者严寒来回答一下，但我理解其实他应该会更宽，因为他按照我刚才前面我理解的这个原理，就是说其实它就是正常的，比如说截图，就是你用手机截图的话，其实你现在看到了什么，它其实就能截出来是什么。但这个可能需要客户端同学补充一下。

那我理解，如果是这样子的话，那它其实这也是它一个，就是更大的一个优点，就是不只是延迟这一方面。

对，是的。

OK，还有问题吗？

没有的话那我们今天的分享就先结束啦，OK，拜拜。


`;
export default async function Detail({ params }: { params: { id: string } }) {
  // const res = await fetch(`${HOST}/query?id=${params.id}`, {
  //   cache: "no-cache",
  // });
  // const sum = await res.text();

  return (
    <div className="grid grid-cols-2 gap-x-3">
      <div
        className="flex flex-col border border-slate-900/10 rounded"
        style={{ maxHeight: "calc(100vh - 116px)" }}
      >
        <a
          href="https://bytedance.feishu.cn/minutes/obcnfce51avh28pmd91g5k6w"
          target="_blank"
          className="block pl-2 py-2 bg-muted font-semibold text-sm italic text-blue-600 break-words"
        >
          https://bytedance.feishu.cn/minutes/obcnfce51avh28pmd91g5k6w
        </a>
        <p className="flex-1 px-2 font-mono text-sm text-slate-600 tracking-wider leading-normal whitespace-pre-line overflow-auto">
          {originText}
        </p>
      </div>
      <Tabs defaultValue="sum" className="w-full">
        <TabsList>
          <TabsTrigger value="sum">Summmarization</TabsTrigger>
          <TabsTrigger value="chat">Chatbot</TabsTrigger>
        </TabsList>
        <TabsContent value="sum">
          <p className="font-mono tracking-wider leading-normal">{sum}</p>
        </TabsContent>
        <TabsContent value="chat">WIP</TabsContent>
      </Tabs>
    </div>
  );
}
